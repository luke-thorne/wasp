// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

#![allow(dead_code)]

use wasmlib::*;
use crate::*;

pub struct CallOnChainCall {
	pub func: ScFunc,
	pub params: MutableCallOnChainParams,
	pub results: ImmutableCallOnChainResults,
}

pub struct CheckContextFromFullEPCall {
	pub func: ScFunc,
	pub params: MutableCheckContextFromFullEPParams,
}

pub struct ClaimAllowanceCall {
	pub func: ScFunc,
}

pub struct DoNothingCall {
	pub func: ScFunc,
}

pub struct EstimateMinDustCall {
	pub func: ScFunc,
}

pub struct IncCounterCall {
	pub func: ScFunc,
}

pub struct InfiniteLoopCall {
	pub func: ScFunc,
}

pub struct InitCall {
	pub func: ScInitFunc,
	pub params: MutableInitParams,
}

pub struct PassTypesFullCall {
	pub func: ScFunc,
	pub params: MutablePassTypesFullParams,
}

pub struct PingAllowanceBackCall {
	pub func: ScFunc,
}

pub struct RunRecursionCall {
	pub func: ScFunc,
	pub params: MutableRunRecursionParams,
	pub results: ImmutableRunRecursionResults,
}

pub struct SendLargeRequestCall {
	pub func: ScFunc,
}

pub struct SendNFTsBackCall {
	pub func: ScFunc,
}

pub struct SendToAddressCall {
	pub func: ScFunc,
}

pub struct SetIntCall {
	pub func: ScFunc,
	pub params: MutableSetIntParams,
}

pub struct SpawnCall {
	pub func: ScFunc,
	pub params: MutableSpawnParams,
}

pub struct SplitFundsCall {
	pub func: ScFunc,
}

pub struct SplitFundsNativeTokensCall {
	pub func: ScFunc,
}

pub struct TestBlockContext1Call {
	pub func: ScFunc,
}

pub struct TestBlockContext2Call {
	pub func: ScFunc,
}

pub struct TestCallPanicFullEPCall {
	pub func: ScFunc,
}

pub struct TestCallPanicViewEPFromFullCall {
	pub func: ScFunc,
}

pub struct TestChainOwnerIDFullCall {
	pub func: ScFunc,
	pub results: ImmutableTestChainOwnerIDFullResults,
}

pub struct TestEventLogDeployCall {
	pub func: ScFunc,
}

pub struct TestEventLogEventDataCall {
	pub func: ScFunc,
}

pub struct TestEventLogGenericDataCall {
	pub func: ScFunc,
	pub params: MutableTestEventLogGenericDataParams,
}

pub struct TestPanicFullEPCall {
	pub func: ScFunc,
}

pub struct WithdrawFromChainCall {
	pub func: ScFunc,
	pub params: MutableWithdrawFromChainParams,
}

pub struct CheckContextFromViewEPCall {
	pub func: ScView,
	pub params: MutableCheckContextFromViewEPParams,
}

pub struct FibonacciCall {
	pub func: ScView,
	pub params: MutableFibonacciParams,
	pub results: ImmutableFibonacciResults,
}

pub struct FibonacciIndirectCall {
	pub func: ScView,
	pub params: MutableFibonacciIndirectParams,
	pub results: ImmutableFibonacciIndirectResults,
}

pub struct GetCounterCall {
	pub func: ScView,
	pub results: ImmutableGetCounterResults,
}

pub struct GetIntCall {
	pub func: ScView,
	pub params: MutableGetIntParams,
	pub results: ImmutableGetIntResults,
}

pub struct GetStringValueCall {
	pub func: ScView,
	pub params: MutableGetStringValueParams,
	pub results: ImmutableGetStringValueResults,
}

pub struct InfiniteLoopViewCall {
	pub func: ScView,
}

pub struct JustViewCall {
	pub func: ScView,
}

pub struct PassTypesViewCall {
	pub func: ScView,
	pub params: MutablePassTypesViewParams,
}

pub struct TestCallPanicViewEPFromViewCall {
	pub func: ScView,
}

pub struct TestChainOwnerIDViewCall {
	pub func: ScView,
	pub results: ImmutableTestChainOwnerIDViewResults,
}

pub struct TestPanicViewEPCall {
	pub func: ScView,
}

pub struct TestSandboxCallCall {
	pub func: ScView,
	pub results: ImmutableTestSandboxCallResults,
}

pub struct ScFuncs {
}

impl ScFuncs {
    pub fn call_on_chain(_ctx: &dyn ScFuncCallContext) -> CallOnChainCall {
        let mut f = CallOnChainCall {
            func: ScFunc::new(HSC_NAME, HFUNC_CALL_ON_CHAIN),
            params: MutableCallOnChainParams { proxy: Proxy::nil() },
            results: ImmutableCallOnChainResults { proxy: Proxy::nil() },
        };
        ScFunc::link_params(&mut f.params.proxy, &f.func);
        ScFunc::link_results(&mut f.results.proxy, &f.func);
        f
    }

    pub fn check_context_from_full_ep(_ctx: &dyn ScFuncCallContext) -> CheckContextFromFullEPCall {
        let mut f = CheckContextFromFullEPCall {
            func: ScFunc::new(HSC_NAME, HFUNC_CHECK_CONTEXT_FROM_FULL_EP),
            params: MutableCheckContextFromFullEPParams { proxy: Proxy::nil() },
        };
        ScFunc::link_params(&mut f.params.proxy, &f.func);
        f
    }

    pub fn claim_allowance(_ctx: &dyn ScFuncCallContext) -> ClaimAllowanceCall {
        ClaimAllowanceCall {
            func: ScFunc::new(HSC_NAME, HFUNC_CLAIM_ALLOWANCE),
        }
    }

    pub fn do_nothing(_ctx: &dyn ScFuncCallContext) -> DoNothingCall {
        DoNothingCall {
            func: ScFunc::new(HSC_NAME, HFUNC_DO_NOTHING),
        }
    }

    pub fn estimate_min_dust(_ctx: &dyn ScFuncCallContext) -> EstimateMinDustCall {
        EstimateMinDustCall {
            func: ScFunc::new(HSC_NAME, HFUNC_ESTIMATE_MIN_DUST),
        }
    }

    pub fn inc_counter(_ctx: &dyn ScFuncCallContext) -> IncCounterCall {
        IncCounterCall {
            func: ScFunc::new(HSC_NAME, HFUNC_INC_COUNTER),
        }
    }

    pub fn infinite_loop(_ctx: &dyn ScFuncCallContext) -> InfiniteLoopCall {
        InfiniteLoopCall {
            func: ScFunc::new(HSC_NAME, HFUNC_INFINITE_LOOP),
        }
    }

    pub fn init(_ctx: &dyn ScFuncCallContext) -> InitCall {
        let mut f = InitCall {
            func: ScInitFunc::new(HSC_NAME, HFUNC_INIT),
            params: MutableInitParams { proxy: Proxy::nil() },
        };
        ScInitFunc::link_params(&mut f.params.proxy, &f.func);
        f
    }

    pub fn pass_types_full(_ctx: &dyn ScFuncCallContext) -> PassTypesFullCall {
        let mut f = PassTypesFullCall {
            func: ScFunc::new(HSC_NAME, HFUNC_PASS_TYPES_FULL),
            params: MutablePassTypesFullParams { proxy: Proxy::nil() },
        };
        ScFunc::link_params(&mut f.params.proxy, &f.func);
        f
    }

    pub fn ping_allowance_back(_ctx: &dyn ScFuncCallContext) -> PingAllowanceBackCall {
        PingAllowanceBackCall {
            func: ScFunc::new(HSC_NAME, HFUNC_PING_ALLOWANCE_BACK),
        }
    }

    pub fn run_recursion(_ctx: &dyn ScFuncCallContext) -> RunRecursionCall {
        let mut f = RunRecursionCall {
            func: ScFunc::new(HSC_NAME, HFUNC_RUN_RECURSION),
            params: MutableRunRecursionParams { proxy: Proxy::nil() },
            results: ImmutableRunRecursionResults { proxy: Proxy::nil() },
        };
        ScFunc::link_params(&mut f.params.proxy, &f.func);
        ScFunc::link_results(&mut f.results.proxy, &f.func);
        f
    }

    pub fn send_large_request(_ctx: &dyn ScFuncCallContext) -> SendLargeRequestCall {
        SendLargeRequestCall {
            func: ScFunc::new(HSC_NAME, HFUNC_SEND_LARGE_REQUEST),
        }
    }

    pub fn send_nf_ts_back(_ctx: &dyn ScFuncCallContext) -> SendNFTsBackCall {
        SendNFTsBackCall {
            func: ScFunc::new(HSC_NAME, HFUNC_SEND_NF_TS_BACK),
        }
    }

    pub fn send_to_address(_ctx: &dyn ScFuncCallContext) -> SendToAddressCall {
        SendToAddressCall {
            func: ScFunc::new(HSC_NAME, HFUNC_SEND_TO_ADDRESS),
        }
    }

    pub fn set_int(_ctx: &dyn ScFuncCallContext) -> SetIntCall {
        let mut f = SetIntCall {
            func: ScFunc::new(HSC_NAME, HFUNC_SET_INT),
            params: MutableSetIntParams { proxy: Proxy::nil() },
        };
        ScFunc::link_params(&mut f.params.proxy, &f.func);
        f
    }

    pub fn spawn(_ctx: &dyn ScFuncCallContext) -> SpawnCall {
        let mut f = SpawnCall {
            func: ScFunc::new(HSC_NAME, HFUNC_SPAWN),
            params: MutableSpawnParams { proxy: Proxy::nil() },
        };
        ScFunc::link_params(&mut f.params.proxy, &f.func);
        f
    }

    pub fn split_funds(_ctx: &dyn ScFuncCallContext) -> SplitFundsCall {
        SplitFundsCall {
            func: ScFunc::new(HSC_NAME, HFUNC_SPLIT_FUNDS),
        }
    }

    pub fn split_funds_native_tokens(_ctx: &dyn ScFuncCallContext) -> SplitFundsNativeTokensCall {
        SplitFundsNativeTokensCall {
            func: ScFunc::new(HSC_NAME, HFUNC_SPLIT_FUNDS_NATIVE_TOKENS),
        }
    }

    pub fn test_block_context1(_ctx: &dyn ScFuncCallContext) -> TestBlockContext1Call {
        TestBlockContext1Call {
            func: ScFunc::new(HSC_NAME, HFUNC_TEST_BLOCK_CONTEXT1),
        }
    }

    pub fn test_block_context2(_ctx: &dyn ScFuncCallContext) -> TestBlockContext2Call {
        TestBlockContext2Call {
            func: ScFunc::new(HSC_NAME, HFUNC_TEST_BLOCK_CONTEXT2),
        }
    }

    pub fn test_call_panic_full_ep(_ctx: &dyn ScFuncCallContext) -> TestCallPanicFullEPCall {
        TestCallPanicFullEPCall {
            func: ScFunc::new(HSC_NAME, HFUNC_TEST_CALL_PANIC_FULL_EP),
        }
    }

    pub fn test_call_panic_view_ep_from_full(_ctx: &dyn ScFuncCallContext) -> TestCallPanicViewEPFromFullCall {
        TestCallPanicViewEPFromFullCall {
            func: ScFunc::new(HSC_NAME, HFUNC_TEST_CALL_PANIC_VIEW_EP_FROM_FULL),
        }
    }

    pub fn test_chain_owner_id_full(_ctx: &dyn ScFuncCallContext) -> TestChainOwnerIDFullCall {
        let mut f = TestChainOwnerIDFullCall {
            func: ScFunc::new(HSC_NAME, HFUNC_TEST_CHAIN_OWNER_ID_FULL),
            results: ImmutableTestChainOwnerIDFullResults { proxy: Proxy::nil() },
        };
        ScFunc::link_results(&mut f.results.proxy, &f.func);
        f
    }

    pub fn test_event_log_deploy(_ctx: &dyn ScFuncCallContext) -> TestEventLogDeployCall {
        TestEventLogDeployCall {
            func: ScFunc::new(HSC_NAME, HFUNC_TEST_EVENT_LOG_DEPLOY),
        }
    }

    pub fn test_event_log_event_data(_ctx: &dyn ScFuncCallContext) -> TestEventLogEventDataCall {
        TestEventLogEventDataCall {
            func: ScFunc::new(HSC_NAME, HFUNC_TEST_EVENT_LOG_EVENT_DATA),
        }
    }

    pub fn test_event_log_generic_data(_ctx: &dyn ScFuncCallContext) -> TestEventLogGenericDataCall {
        let mut f = TestEventLogGenericDataCall {
            func: ScFunc::new(HSC_NAME, HFUNC_TEST_EVENT_LOG_GENERIC_DATA),
            params: MutableTestEventLogGenericDataParams { proxy: Proxy::nil() },
        };
        ScFunc::link_params(&mut f.params.proxy, &f.func);
        f
    }

    pub fn test_panic_full_ep(_ctx: &dyn ScFuncCallContext) -> TestPanicFullEPCall {
        TestPanicFullEPCall {
            func: ScFunc::new(HSC_NAME, HFUNC_TEST_PANIC_FULL_EP),
        }
    }

    pub fn withdraw_from_chain(_ctx: &dyn ScFuncCallContext) -> WithdrawFromChainCall {
        let mut f = WithdrawFromChainCall {
            func: ScFunc::new(HSC_NAME, HFUNC_WITHDRAW_FROM_CHAIN),
            params: MutableWithdrawFromChainParams { proxy: Proxy::nil() },
        };
        ScFunc::link_params(&mut f.params.proxy, &f.func);
        f
    }

    pub fn check_context_from_view_ep(_ctx: &dyn ScViewCallContext) -> CheckContextFromViewEPCall {
        let mut f = CheckContextFromViewEPCall {
            func: ScView::new(HSC_NAME, HVIEW_CHECK_CONTEXT_FROM_VIEW_EP),
            params: MutableCheckContextFromViewEPParams { proxy: Proxy::nil() },
        };
        ScView::link_params(&mut f.params.proxy, &f.func);
        f
    }

    pub fn fibonacci(_ctx: &dyn ScViewCallContext) -> FibonacciCall {
        let mut f = FibonacciCall {
            func: ScView::new(HSC_NAME, HVIEW_FIBONACCI),
            params: MutableFibonacciParams { proxy: Proxy::nil() },
            results: ImmutableFibonacciResults { proxy: Proxy::nil() },
        };
        ScView::link_params(&mut f.params.proxy, &f.func);
        ScView::link_results(&mut f.results.proxy, &f.func);
        f
    }

    pub fn fibonacci_indirect(_ctx: &dyn ScViewCallContext) -> FibonacciIndirectCall {
        let mut f = FibonacciIndirectCall {
            func: ScView::new(HSC_NAME, HVIEW_FIBONACCI_INDIRECT),
            params: MutableFibonacciIndirectParams { proxy: Proxy::nil() },
            results: ImmutableFibonacciIndirectResults { proxy: Proxy::nil() },
        };
        ScView::link_params(&mut f.params.proxy, &f.func);
        ScView::link_results(&mut f.results.proxy, &f.func);
        f
    }

    pub fn get_counter(_ctx: &dyn ScViewCallContext) -> GetCounterCall {
        let mut f = GetCounterCall {
            func: ScView::new(HSC_NAME, HVIEW_GET_COUNTER),
            results: ImmutableGetCounterResults { proxy: Proxy::nil() },
        };
        ScView::link_results(&mut f.results.proxy, &f.func);
        f
    }

    pub fn get_int(_ctx: &dyn ScViewCallContext) -> GetIntCall {
        let mut f = GetIntCall {
            func: ScView::new(HSC_NAME, HVIEW_GET_INT),
            params: MutableGetIntParams { proxy: Proxy::nil() },
            results: ImmutableGetIntResults { proxy: Proxy::nil() },
        };
        ScView::link_params(&mut f.params.proxy, &f.func);
        ScView::link_results(&mut f.results.proxy, &f.func);
        f
    }

    pub fn get_string_value(_ctx: &dyn ScViewCallContext) -> GetStringValueCall {
        let mut f = GetStringValueCall {
            func: ScView::new(HSC_NAME, HVIEW_GET_STRING_VALUE),
            params: MutableGetStringValueParams { proxy: Proxy::nil() },
            results: ImmutableGetStringValueResults { proxy: Proxy::nil() },
        };
        ScView::link_params(&mut f.params.proxy, &f.func);
        ScView::link_results(&mut f.results.proxy, &f.func);
        f
    }

    pub fn infinite_loop_view(_ctx: &dyn ScViewCallContext) -> InfiniteLoopViewCall {
        InfiniteLoopViewCall {
            func: ScView::new(HSC_NAME, HVIEW_INFINITE_LOOP_VIEW),
        }
    }

    pub fn just_view(_ctx: &dyn ScViewCallContext) -> JustViewCall {
        JustViewCall {
            func: ScView::new(HSC_NAME, HVIEW_JUST_VIEW),
        }
    }

    pub fn pass_types_view(_ctx: &dyn ScViewCallContext) -> PassTypesViewCall {
        let mut f = PassTypesViewCall {
            func: ScView::new(HSC_NAME, HVIEW_PASS_TYPES_VIEW),
            params: MutablePassTypesViewParams { proxy: Proxy::nil() },
        };
        ScView::link_params(&mut f.params.proxy, &f.func);
        f
    }

    pub fn test_call_panic_view_ep_from_view(_ctx: &dyn ScViewCallContext) -> TestCallPanicViewEPFromViewCall {
        TestCallPanicViewEPFromViewCall {
            func: ScView::new(HSC_NAME, HVIEW_TEST_CALL_PANIC_VIEW_EP_FROM_VIEW),
        }
    }

    pub fn test_chain_owner_id_view(_ctx: &dyn ScViewCallContext) -> TestChainOwnerIDViewCall {
        let mut f = TestChainOwnerIDViewCall {
            func: ScView::new(HSC_NAME, HVIEW_TEST_CHAIN_OWNER_ID_VIEW),
            results: ImmutableTestChainOwnerIDViewResults { proxy: Proxy::nil() },
        };
        ScView::link_results(&mut f.results.proxy, &f.func);
        f
    }

    pub fn test_panic_view_ep(_ctx: &dyn ScViewCallContext) -> TestPanicViewEPCall {
        TestPanicViewEPCall {
            func: ScView::new(HSC_NAME, HVIEW_TEST_PANIC_VIEW_EP),
        }
    }

    pub fn test_sandbox_call(_ctx: &dyn ScViewCallContext) -> TestSandboxCallCall {
        let mut f = TestSandboxCallCall {
            func: ScView::new(HSC_NAME, HVIEW_TEST_SANDBOX_CALL),
            results: ImmutableTestSandboxCallResults { proxy: Proxy::nil() },
        };
        ScView::link_results(&mut f.results.proxy, &f.func);
        f
    }
}
