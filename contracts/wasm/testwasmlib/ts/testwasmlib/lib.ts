// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

import * as wasmlib from "wasmlib";
import * as sc from "./index";

const exportMap: wasmlib.ScExportMap = {
	names: [
		sc.FuncAddressMapOfAddressArrayAppend,
		sc.FuncAddressMapOfAddressArrayClear,
		sc.FuncAddressMapOfAddressArraySet,
		sc.FuncAddressMapOfAddressMapClear,
		sc.FuncAddressMapOfAddressMapSet,
		sc.FuncArrayOfAddressArrayAppend,
		sc.FuncArrayOfAddressArrayClear,
		sc.FuncArrayOfAddressArraySet,
		sc.FuncArrayOfAddressMapClear,
		sc.FuncArrayOfAddressMapSet,
		sc.FuncArrayOfStringArrayAppend,
		sc.FuncArrayOfStringArrayClear,
		sc.FuncArrayOfStringArraySet,
		sc.FuncArrayOfStringMapClear,
		sc.FuncArrayOfStringMapSet,
		sc.FuncParamTypes,
		sc.FuncRandom,
		sc.FuncStringMapOfStringArrayAppend,
		sc.FuncStringMapOfStringArrayClear,
		sc.FuncStringMapOfStringArraySet,
		sc.FuncStringMapOfStringMapClear,
		sc.FuncStringMapOfStringMapSet,
		sc.FuncTakeAllowance,
		sc.FuncTakeBalance,
		sc.FuncTriggerEvent,
		sc.ViewAddressMapOfAddressArrayLength,
		sc.ViewAddressMapOfAddressArrayValue,
		sc.ViewAddressMapOfAddressMapValue,
		sc.ViewArrayOfAddressArrayLength,
		sc.ViewArrayOfAddressArrayValue,
		sc.ViewArrayOfAddressMapValue,
		sc.ViewArrayOfStringArrayLength,
		sc.ViewArrayOfStringArrayValue,
		sc.ViewArrayOfStringMapValue,
		sc.ViewBigIntAdd,
		sc.ViewBigIntDiv,
		sc.ViewBigIntMod,
		sc.ViewBigIntMul,
		sc.ViewBigIntShl,
		sc.ViewBigIntShr,
		sc.ViewBigIntSub,
		sc.ViewBlockRecord,
		sc.ViewBlockRecords,
		sc.ViewGetRandom,
		sc.ViewIotaBalance,
		sc.ViewStringMapOfStringArrayLength,
		sc.ViewStringMapOfStringArrayValue,
		sc.ViewStringMapOfStringMapValue,
	],
	funcs: [
		funcAddressMapOfAddressArrayAppendThunk,
		funcAddressMapOfAddressArrayClearThunk,
		funcAddressMapOfAddressArraySetThunk,
		funcAddressMapOfAddressMapClearThunk,
		funcAddressMapOfAddressMapSetThunk,
		funcArrayOfAddressArrayAppendThunk,
		funcArrayOfAddressArrayClearThunk,
		funcArrayOfAddressArraySetThunk,
		funcArrayOfAddressMapClearThunk,
		funcArrayOfAddressMapSetThunk,
		funcArrayOfStringArrayAppendThunk,
		funcArrayOfStringArrayClearThunk,
		funcArrayOfStringArraySetThunk,
		funcArrayOfStringMapClearThunk,
		funcArrayOfStringMapSetThunk,
		funcParamTypesThunk,
		funcRandomThunk,
		funcStringMapOfStringArrayAppendThunk,
		funcStringMapOfStringArrayClearThunk,
		funcStringMapOfStringArraySetThunk,
		funcStringMapOfStringMapClearThunk,
		funcStringMapOfStringMapSetThunk,
		funcTakeAllowanceThunk,
		funcTakeBalanceThunk,
		funcTriggerEventThunk,
	],
	views: [
		viewAddressMapOfAddressArrayLengthThunk,
		viewAddressMapOfAddressArrayValueThunk,
		viewAddressMapOfAddressMapValueThunk,
		viewArrayOfAddressArrayLengthThunk,
		viewArrayOfAddressArrayValueThunk,
		viewArrayOfAddressMapValueThunk,
		viewArrayOfStringArrayLengthThunk,
		viewArrayOfStringArrayValueThunk,
		viewArrayOfStringMapValueThunk,
		viewBigIntAddThunk,
		viewBigIntDivThunk,
		viewBigIntModThunk,
		viewBigIntMulThunk,
		viewBigIntShlThunk,
		viewBigIntShrThunk,
		viewBigIntSubThunk,
		viewBlockRecordThunk,
		viewBlockRecordsThunk,
		viewGetRandomThunk,
		viewIotaBalanceThunk,
		viewStringMapOfStringArrayLengthThunk,
		viewStringMapOfStringArrayValueThunk,
		viewStringMapOfStringMapValueThunk,
	],
};

export function on_call(index: i32): void {
	wasmlib.WasmVMHost.connect();
	wasmlib.ScExports.call(index, exportMap);
}

export function on_load(): void {
	wasmlib.WasmVMHost.connect();
	wasmlib.ScExports.export(exportMap);
}

function funcAddressMapOfAddressArrayAppendThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcAddressMapOfAddressArrayAppend");
	let f = new sc.AddressMapOfAddressArrayAppendContext();
	ctx.require(f.params.nameAddr().exists(), "missing mandatory nameAddr");
	ctx.require(f.params.valueAddr().exists(), "missing mandatory valueAddr");
	sc.funcAddressMapOfAddressArrayAppend(ctx, f);
	ctx.log("testwasmlib.funcAddressMapOfAddressArrayAppend ok");
}

function funcAddressMapOfAddressArrayClearThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcAddressMapOfAddressArrayClear");
	let f = new sc.AddressMapOfAddressArrayClearContext();
	ctx.require(f.params.nameAddr().exists(), "missing mandatory nameAddr");
	sc.funcAddressMapOfAddressArrayClear(ctx, f);
	ctx.log("testwasmlib.funcAddressMapOfAddressArrayClear ok");
}

function funcAddressMapOfAddressArraySetThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcAddressMapOfAddressArraySet");
	let f = new sc.AddressMapOfAddressArraySetContext();
	ctx.require(f.params.index().exists(), "missing mandatory index");
	ctx.require(f.params.nameAddr().exists(), "missing mandatory nameAddr");
	ctx.require(f.params.valueAddr().exists(), "missing mandatory valueAddr");
	sc.funcAddressMapOfAddressArraySet(ctx, f);
	ctx.log("testwasmlib.funcAddressMapOfAddressArraySet ok");
}

function funcAddressMapOfAddressMapClearThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcAddressMapOfAddressMapClear");
	let f = new sc.AddressMapOfAddressMapClearContext();
	ctx.require(f.params.nameAddr().exists(), "missing mandatory nameAddr");
	sc.funcAddressMapOfAddressMapClear(ctx, f);
	ctx.log("testwasmlib.funcAddressMapOfAddressMapClear ok");
}

function funcAddressMapOfAddressMapSetThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcAddressMapOfAddressMapSet");
	let f = new sc.AddressMapOfAddressMapSetContext();
	ctx.require(f.params.keyAddr().exists(), "missing mandatory keyAddr");
	ctx.require(f.params.nameAddr().exists(), "missing mandatory nameAddr");
	ctx.require(f.params.valueAddr().exists(), "missing mandatory valueAddr");
	sc.funcAddressMapOfAddressMapSet(ctx, f);
	ctx.log("testwasmlib.funcAddressMapOfAddressMapSet ok");
}

function funcArrayOfAddressArrayAppendThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcArrayOfAddressArrayAppend");
	let f = new sc.ArrayOfAddressArrayAppendContext();
	ctx.require(f.params.index().exists(), "missing mandatory index");
	sc.funcArrayOfAddressArrayAppend(ctx, f);
	ctx.log("testwasmlib.funcArrayOfAddressArrayAppend ok");
}

function funcArrayOfAddressArrayClearThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcArrayOfAddressArrayClear");
	let f = new sc.ArrayOfAddressArrayClearContext();
	sc.funcArrayOfAddressArrayClear(ctx, f);
	ctx.log("testwasmlib.funcArrayOfAddressArrayClear ok");
}

function funcArrayOfAddressArraySetThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcArrayOfAddressArraySet");
	let f = new sc.ArrayOfAddressArraySetContext();
	ctx.require(f.params.index0().exists(), "missing mandatory index0");
	ctx.require(f.params.index1().exists(), "missing mandatory index1");
	ctx.require(f.params.valueAddr().exists(), "missing mandatory valueAddr");
	sc.funcArrayOfAddressArraySet(ctx, f);
	ctx.log("testwasmlib.funcArrayOfAddressArraySet ok");
}

function funcArrayOfAddressMapClearThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcArrayOfAddressMapClear");
	let f = new sc.ArrayOfAddressMapClearContext();
	sc.funcArrayOfAddressMapClear(ctx, f);
	ctx.log("testwasmlib.funcArrayOfAddressMapClear ok");
}

function funcArrayOfAddressMapSetThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcArrayOfAddressMapSet");
	let f = new sc.ArrayOfAddressMapSetContext();
	ctx.require(f.params.index().exists(), "missing mandatory index");
	ctx.require(f.params.keyAddr().exists(), "missing mandatory keyAddr");
	ctx.require(f.params.valueAddr().exists(), "missing mandatory valueAddr");
	sc.funcArrayOfAddressMapSet(ctx, f);
	ctx.log("testwasmlib.funcArrayOfAddressMapSet ok");
}

function funcArrayOfStringArrayAppendThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcArrayOfStringArrayAppend");
	let f = new sc.ArrayOfStringArrayAppendContext();
	ctx.require(f.params.index().exists(), "missing mandatory index");
	sc.funcArrayOfStringArrayAppend(ctx, f);
	ctx.log("testwasmlib.funcArrayOfStringArrayAppend ok");
}

function funcArrayOfStringArrayClearThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcArrayOfStringArrayClear");
	let f = new sc.ArrayOfStringArrayClearContext();
	sc.funcArrayOfStringArrayClear(ctx, f);
	ctx.log("testwasmlib.funcArrayOfStringArrayClear ok");
}

function funcArrayOfStringArraySetThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcArrayOfStringArraySet");
	let f = new sc.ArrayOfStringArraySetContext();
	ctx.require(f.params.index0().exists(), "missing mandatory index0");
	ctx.require(f.params.index1().exists(), "missing mandatory index1");
	ctx.require(f.params.value().exists(), "missing mandatory value");
	sc.funcArrayOfStringArraySet(ctx, f);
	ctx.log("testwasmlib.funcArrayOfStringArraySet ok");
}

function funcArrayOfStringMapClearThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcArrayOfStringMapClear");
	let f = new sc.ArrayOfStringMapClearContext();
	sc.funcArrayOfStringMapClear(ctx, f);
	ctx.log("testwasmlib.funcArrayOfStringMapClear ok");
}

function funcArrayOfStringMapSetThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcArrayOfStringMapSet");
	let f = new sc.ArrayOfStringMapSetContext();
	ctx.require(f.params.index().exists(), "missing mandatory index");
	ctx.require(f.params.key().exists(), "missing mandatory key");
	ctx.require(f.params.value().exists(), "missing mandatory value");
	sc.funcArrayOfStringMapSet(ctx, f);
	ctx.log("testwasmlib.funcArrayOfStringMapSet ok");
}

function funcParamTypesThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcParamTypes");
	let f = new sc.ParamTypesContext();
	sc.funcParamTypes(ctx, f);
	ctx.log("testwasmlib.funcParamTypes ok");
}

function funcRandomThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcRandom");
	let f = new sc.RandomContext();
	sc.funcRandom(ctx, f);
	ctx.log("testwasmlib.funcRandom ok");
}

function funcStringMapOfStringArrayAppendThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcStringMapOfStringArrayAppend");
	let f = new sc.StringMapOfStringArrayAppendContext();
	ctx.require(f.params.name().exists(), "missing mandatory name");
	ctx.require(f.params.value().exists(), "missing mandatory value");
	sc.funcStringMapOfStringArrayAppend(ctx, f);
	ctx.log("testwasmlib.funcStringMapOfStringArrayAppend ok");
}

function funcStringMapOfStringArrayClearThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcStringMapOfStringArrayClear");
	let f = new sc.StringMapOfStringArrayClearContext();
	ctx.require(f.params.name().exists(), "missing mandatory name");
	sc.funcStringMapOfStringArrayClear(ctx, f);
	ctx.log("testwasmlib.funcStringMapOfStringArrayClear ok");
}

function funcStringMapOfStringArraySetThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcStringMapOfStringArraySet");
	let f = new sc.StringMapOfStringArraySetContext();
	ctx.require(f.params.index().exists(), "missing mandatory index");
	ctx.require(f.params.name().exists(), "missing mandatory name");
	ctx.require(f.params.value().exists(), "missing mandatory value");
	sc.funcStringMapOfStringArraySet(ctx, f);
	ctx.log("testwasmlib.funcStringMapOfStringArraySet ok");
}

function funcStringMapOfStringMapClearThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcStringMapOfStringMapClear");
	let f = new sc.StringMapOfStringMapClearContext();
	ctx.require(f.params.name().exists(), "missing mandatory name");
	sc.funcStringMapOfStringMapClear(ctx, f);
	ctx.log("testwasmlib.funcStringMapOfStringMapClear ok");
}

function funcStringMapOfStringMapSetThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcStringMapOfStringMapSet");
	let f = new sc.StringMapOfStringMapSetContext();
	ctx.require(f.params.key().exists(), "missing mandatory key");
	ctx.require(f.params.name().exists(), "missing mandatory name");
	ctx.require(f.params.value().exists(), "missing mandatory value");
	sc.funcStringMapOfStringMapSet(ctx, f);
	ctx.log("testwasmlib.funcStringMapOfStringMapSet ok");
}

function funcTakeAllowanceThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcTakeAllowance");
	let f = new sc.TakeAllowanceContext();
	sc.funcTakeAllowance(ctx, f);
	ctx.log("testwasmlib.funcTakeAllowance ok");
}

function funcTakeBalanceThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcTakeBalance");
	let f = new sc.TakeBalanceContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableTakeBalanceResults(results.asProxy());
	sc.funcTakeBalance(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.funcTakeBalance ok");
}

function funcTriggerEventThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("testwasmlib.funcTriggerEvent");
	let f = new sc.TriggerEventContext();
	ctx.require(f.params.address().exists(), "missing mandatory address");
	ctx.require(f.params.name().exists(), "missing mandatory name");
	sc.funcTriggerEvent(ctx, f);
	ctx.log("testwasmlib.funcTriggerEvent ok");
}

function viewAddressMapOfAddressArrayLengthThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewAddressMapOfAddressArrayLength");
	let f = new sc.AddressMapOfAddressArrayLengthContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableAddressMapOfAddressArrayLengthResults(results.asProxy());
	ctx.require(f.params.nameAddr().exists(), "missing mandatory nameAddr");
	sc.viewAddressMapOfAddressArrayLength(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewAddressMapOfAddressArrayLength ok");
}

function viewAddressMapOfAddressArrayValueThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewAddressMapOfAddressArrayValue");
	let f = new sc.AddressMapOfAddressArrayValueContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableAddressMapOfAddressArrayValueResults(results.asProxy());
	ctx.require(f.params.index().exists(), "missing mandatory index");
	ctx.require(f.params.nameAddr().exists(), "missing mandatory nameAddr");
	sc.viewAddressMapOfAddressArrayValue(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewAddressMapOfAddressArrayValue ok");
}

function viewAddressMapOfAddressMapValueThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewAddressMapOfAddressMapValue");
	let f = new sc.AddressMapOfAddressMapValueContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableAddressMapOfAddressMapValueResults(results.asProxy());
	ctx.require(f.params.keyAddr().exists(), "missing mandatory keyAddr");
	ctx.require(f.params.nameAddr().exists(), "missing mandatory nameAddr");
	sc.viewAddressMapOfAddressMapValue(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewAddressMapOfAddressMapValue ok");
}

function viewArrayOfAddressArrayLengthThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewArrayOfAddressArrayLength");
	let f = new sc.ArrayOfAddressArrayLengthContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableArrayOfAddressArrayLengthResults(results.asProxy());
	sc.viewArrayOfAddressArrayLength(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewArrayOfAddressArrayLength ok");
}

function viewArrayOfAddressArrayValueThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewArrayOfAddressArrayValue");
	let f = new sc.ArrayOfAddressArrayValueContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableArrayOfAddressArrayValueResults(results.asProxy());
	ctx.require(f.params.index0().exists(), "missing mandatory index0");
	ctx.require(f.params.index1().exists(), "missing mandatory index1");
	sc.viewArrayOfAddressArrayValue(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewArrayOfAddressArrayValue ok");
}

function viewArrayOfAddressMapValueThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewArrayOfAddressMapValue");
	let f = new sc.ArrayOfAddressMapValueContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableArrayOfAddressMapValueResults(results.asProxy());
	ctx.require(f.params.index().exists(), "missing mandatory index");
	ctx.require(f.params.keyAddr().exists(), "missing mandatory keyAddr");
	sc.viewArrayOfAddressMapValue(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewArrayOfAddressMapValue ok");
}

function viewArrayOfStringArrayLengthThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewArrayOfStringArrayLength");
	let f = new sc.ArrayOfStringArrayLengthContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableArrayOfStringArrayLengthResults(results.asProxy());
	sc.viewArrayOfStringArrayLength(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewArrayOfStringArrayLength ok");
}

function viewArrayOfStringArrayValueThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewArrayOfStringArrayValue");
	let f = new sc.ArrayOfStringArrayValueContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableArrayOfStringArrayValueResults(results.asProxy());
	ctx.require(f.params.index0().exists(), "missing mandatory index0");
	ctx.require(f.params.index1().exists(), "missing mandatory index1");
	sc.viewArrayOfStringArrayValue(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewArrayOfStringArrayValue ok");
}

function viewArrayOfStringMapValueThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewArrayOfStringMapValue");
	let f = new sc.ArrayOfStringMapValueContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableArrayOfStringMapValueResults(results.asProxy());
	ctx.require(f.params.index().exists(), "missing mandatory index");
	ctx.require(f.params.key().exists(), "missing mandatory key");
	sc.viewArrayOfStringMapValue(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewArrayOfStringMapValue ok");
}

function viewBigIntAddThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewBigIntAdd");
	let f = new sc.BigIntAddContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableBigIntAddResults(results.asProxy());
	ctx.require(f.params.lhs().exists(), "missing mandatory lhs");
	ctx.require(f.params.rhs().exists(), "missing mandatory rhs");
	sc.viewBigIntAdd(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewBigIntAdd ok");
}

function viewBigIntDivThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewBigIntDiv");
	let f = new sc.BigIntDivContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableBigIntDivResults(results.asProxy());
	ctx.require(f.params.lhs().exists(), "missing mandatory lhs");
	ctx.require(f.params.rhs().exists(), "missing mandatory rhs");
	sc.viewBigIntDiv(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewBigIntDiv ok");
}

function viewBigIntModThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewBigIntMod");
	let f = new sc.BigIntModContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableBigIntModResults(results.asProxy());
	ctx.require(f.params.lhs().exists(), "missing mandatory lhs");
	ctx.require(f.params.rhs().exists(), "missing mandatory rhs");
	sc.viewBigIntMod(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewBigIntMod ok");
}

function viewBigIntMulThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewBigIntMul");
	let f = new sc.BigIntMulContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableBigIntMulResults(results.asProxy());
	ctx.require(f.params.lhs().exists(), "missing mandatory lhs");
	ctx.require(f.params.rhs().exists(), "missing mandatory rhs");
	sc.viewBigIntMul(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewBigIntMul ok");
}

function viewBigIntShlThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewBigIntShl");
	let f = new sc.BigIntShlContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableBigIntShlResults(results.asProxy());
	ctx.require(f.params.lhs().exists(), "missing mandatory lhs");
	ctx.require(f.params.shift().exists(), "missing mandatory shift");
	sc.viewBigIntShl(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewBigIntShl ok");
}

function viewBigIntShrThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewBigIntShr");
	let f = new sc.BigIntShrContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableBigIntShrResults(results.asProxy());
	ctx.require(f.params.lhs().exists(), "missing mandatory lhs");
	ctx.require(f.params.shift().exists(), "missing mandatory shift");
	sc.viewBigIntShr(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewBigIntShr ok");
}

function viewBigIntSubThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewBigIntSub");
	let f = new sc.BigIntSubContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableBigIntSubResults(results.asProxy());
	ctx.require(f.params.lhs().exists(), "missing mandatory lhs");
	ctx.require(f.params.rhs().exists(), "missing mandatory rhs");
	sc.viewBigIntSub(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewBigIntSub ok");
}

function viewBlockRecordThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewBlockRecord");
	let f = new sc.BlockRecordContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableBlockRecordResults(results.asProxy());
	ctx.require(f.params.blockIndex().exists(), "missing mandatory blockIndex");
	ctx.require(f.params.recordIndex().exists(), "missing mandatory recordIndex");
	sc.viewBlockRecord(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewBlockRecord ok");
}

function viewBlockRecordsThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewBlockRecords");
	let f = new sc.BlockRecordsContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableBlockRecordsResults(results.asProxy());
	ctx.require(f.params.blockIndex().exists(), "missing mandatory blockIndex");
	sc.viewBlockRecords(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewBlockRecords ok");
}

function viewGetRandomThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewGetRandom");
	let f = new sc.GetRandomContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableGetRandomResults(results.asProxy());
	sc.viewGetRandom(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewGetRandom ok");
}

function viewIotaBalanceThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewIotaBalance");
	let f = new sc.IotaBalanceContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableIotaBalanceResults(results.asProxy());
	sc.viewIotaBalance(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewIotaBalance ok");
}

function viewStringMapOfStringArrayLengthThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewStringMapOfStringArrayLength");
	let f = new sc.StringMapOfStringArrayLengthContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableStringMapOfStringArrayLengthResults(results.asProxy());
	ctx.require(f.params.name().exists(), "missing mandatory name");
	sc.viewStringMapOfStringArrayLength(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewStringMapOfStringArrayLength ok");
}

function viewStringMapOfStringArrayValueThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewStringMapOfStringArrayValue");
	let f = new sc.StringMapOfStringArrayValueContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableStringMapOfStringArrayValueResults(results.asProxy());
	ctx.require(f.params.index().exists(), "missing mandatory index");
	ctx.require(f.params.name().exists(), "missing mandatory name");
	sc.viewStringMapOfStringArrayValue(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewStringMapOfStringArrayValue ok");
}

function viewStringMapOfStringMapValueThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("testwasmlib.viewStringMapOfStringMapValue");
	let f = new sc.StringMapOfStringMapValueContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableStringMapOfStringMapValueResults(results.asProxy());
	ctx.require(f.params.key().exists(), "missing mandatory key");
	ctx.require(f.params.name().exists(), "missing mandatory name");
	sc.viewStringMapOfStringMapValue(ctx, f);
	ctx.results(results);
	ctx.log("testwasmlib.viewStringMapOfStringMapValue ok");
}
