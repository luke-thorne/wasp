// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

import * as wasmlib from "wasmlib";
import * as sc from "./index";

const exportMap: wasmlib.ScExportMap = {
	names: [
		sc.FuncCallIncrement,
		sc.FuncCallIncrementRecurse5x,
		sc.FuncEndlessLoop,
		sc.FuncIncrement,
		sc.FuncIncrementWithDelay,
		sc.FuncInit,
		sc.FuncLocalStateInternalCall,
		sc.FuncLocalStatePost,
		sc.FuncLocalStateSandboxCall,
		sc.FuncPostIncrement,
		sc.FuncRepeatMany,
		sc.FuncTestVliCodec,
		sc.FuncTestVluCodec,
		sc.FuncWhenMustIncrement,
		sc.ViewGetCounter,
		sc.ViewGetVli,
		sc.ViewGetVlu,
	],
	funcs: [
		funcCallIncrementThunk,
		funcCallIncrementRecurse5xThunk,
		funcEndlessLoopThunk,
		funcIncrementThunk,
		funcIncrementWithDelayThunk,
		funcInitThunk,
		funcLocalStateInternalCallThunk,
		funcLocalStatePostThunk,
		funcLocalStateSandboxCallThunk,
		funcPostIncrementThunk,
		funcRepeatManyThunk,
		funcTestVliCodecThunk,
		funcTestVluCodecThunk,
		funcWhenMustIncrementThunk,
	],
	views: [
		viewGetCounterThunk,
		viewGetVliThunk,
		viewGetVluThunk,
	],
};

export function on_call(index: i32): void {
	wasmlib.WasmVMHost.connect();
	wasmlib.ScExports.call(index, exportMap);
}

export function on_load(): void {
	wasmlib.WasmVMHost.connect();
	wasmlib.ScExports.export(exportMap);
}

function funcCallIncrementThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("inccounter.funcCallIncrement");
	let f = new sc.CallIncrementContext();
	sc.funcCallIncrement(ctx, f);
	ctx.log("inccounter.funcCallIncrement ok");
}

function funcCallIncrementRecurse5xThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("inccounter.funcCallIncrementRecurse5x");
	let f = new sc.CallIncrementRecurse5xContext();
	sc.funcCallIncrementRecurse5x(ctx, f);
	ctx.log("inccounter.funcCallIncrementRecurse5x ok");
}

function funcEndlessLoopThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("inccounter.funcEndlessLoop");
	let f = new sc.EndlessLoopContext();
	sc.funcEndlessLoop(ctx, f);
	ctx.log("inccounter.funcEndlessLoop ok");
}

function funcIncrementThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("inccounter.funcIncrement");
	let f = new sc.IncrementContext();
	sc.funcIncrement(ctx, f);
	ctx.log("inccounter.funcIncrement ok");
}

function funcIncrementWithDelayThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("inccounter.funcIncrementWithDelay");
	let f = new sc.IncrementWithDelayContext();
	ctx.require(f.params.delay().exists(), "missing mandatory delay");
	sc.funcIncrementWithDelay(ctx, f);
	ctx.log("inccounter.funcIncrementWithDelay ok");
}

function funcInitThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("inccounter.funcInit");
	let f = new sc.InitContext();
	sc.funcInit(ctx, f);
	ctx.log("inccounter.funcInit ok");
}

function funcLocalStateInternalCallThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("inccounter.funcLocalStateInternalCall");
	let f = new sc.LocalStateInternalCallContext();
	sc.funcLocalStateInternalCall(ctx, f);
	ctx.log("inccounter.funcLocalStateInternalCall ok");
}

function funcLocalStatePostThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("inccounter.funcLocalStatePost");
	let f = new sc.LocalStatePostContext();
	sc.funcLocalStatePost(ctx, f);
	ctx.log("inccounter.funcLocalStatePost ok");
}

function funcLocalStateSandboxCallThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("inccounter.funcLocalStateSandboxCall");
	let f = new sc.LocalStateSandboxCallContext();
	sc.funcLocalStateSandboxCall(ctx, f);
	ctx.log("inccounter.funcLocalStateSandboxCall ok");
}

function funcPostIncrementThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("inccounter.funcPostIncrement");
	let f = new sc.PostIncrementContext();
	sc.funcPostIncrement(ctx, f);
	ctx.log("inccounter.funcPostIncrement ok");
}

function funcRepeatManyThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("inccounter.funcRepeatMany");
	let f = new sc.RepeatManyContext();
	sc.funcRepeatMany(ctx, f);
	ctx.log("inccounter.funcRepeatMany ok");
}

function funcTestVliCodecThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("inccounter.funcTestVliCodec");
	let f = new sc.TestVliCodecContext();
	sc.funcTestVliCodec(ctx, f);
	ctx.log("inccounter.funcTestVliCodec ok");
}

function funcTestVluCodecThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("inccounter.funcTestVluCodec");
	let f = new sc.TestVluCodecContext();
	sc.funcTestVluCodec(ctx, f);
	ctx.log("inccounter.funcTestVluCodec ok");
}

function funcWhenMustIncrementThunk(ctx: wasmlib.ScFuncContext): void {
	ctx.log("inccounter.funcWhenMustIncrement");
	let f = new sc.WhenMustIncrementContext();
	sc.funcWhenMustIncrement(ctx, f);
	ctx.log("inccounter.funcWhenMustIncrement ok");
}

function viewGetCounterThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("inccounter.viewGetCounter");
	let f = new sc.GetCounterContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableGetCounterResults(results.asProxy());
	sc.viewGetCounter(ctx, f);
	ctx.results(results);
	ctx.log("inccounter.viewGetCounter ok");
}

function viewGetVliThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("inccounter.viewGetVli");
	let f = new sc.GetVliContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableGetVliResults(results.asProxy());
	ctx.require(f.params.ni64().exists(), "missing mandatory ni64");
	sc.viewGetVli(ctx, f);
	ctx.results(results);
	ctx.log("inccounter.viewGetVli ok");
}

function viewGetVluThunk(ctx: wasmlib.ScViewContext): void {
	ctx.log("inccounter.viewGetVlu");
	let f = new sc.GetVluContext();
	const results = new wasmlib.ScDict([]);
	f.results = new sc.MutableGetVluResults(results.asProxy());
	ctx.require(f.params.nu64().exists(), "missing mandatory nu64");
	sc.viewGetVlu(ctx, f);
	ctx.results(results);
	ctx.log("inccounter.viewGetVlu ok");
}
